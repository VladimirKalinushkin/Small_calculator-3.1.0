
    Small_calculator - версия 3.1.0
    Работа начата 24.04.2023, закончена - 6.12.2023.

    Автор: Калинушкин Владимир, ya-vladimir-93@yandex.ru
    _______________________________________________
    Новое:

        1) Из функционала:
            Вместо отдельного режима обработки Римских чисел их обработка перенесена в главный режим

        2) Из технического:

            - a) Убрано перечисление с типом режима из констант
            - b) То же в классах Settings и Mathematic_result
            - c) Обновлен класс Roman_int
            - d) Обновлена версия Chrono
            - e) Обработка исключений римских чисел добавлена в главное меню
            - g) Типы лексем обозначены как десятичные цифры 
                    (во-первых, нужно внимательно считывать лексемы)
                    (во-вторых, это даёт больше возможностей для именования переменных)
                    (в третьих, при чтении логов можно будет понять, где произошла ошибка
                         - тип 1 - число, 2 - римское число, и т.д)

    _______________________________________________

    Пояснения:

        - 1) Для чего поле токена устанавливается налом (2.h). На логику работы это никак не влияет:
             токен после создания почти сразу получает реальные значения, а в классе Main_exception токен -
             - часть объекта (для того, чтобы по возможности получить и передать пользователю информацию
             о проблемном месте в выражении (конечно, чтобы найти ошибку в введённом выражении =)) )),
             но, если при инициализации объекта исключения не был передан токен (это не всегда нужно),
             в выводе сообщения не нужно выводить "случайные" значения "встроенного" токена,
             достаточно ограничиться строкой "no_token" в логе, а в консоли вообще ничего не выводить

        - 2) Объект класса TokenStream должен инициализироваться с адресом Settings. Для этого в объекте
             класса Stream есть поле указателем на кобъект Settings. Этого можно было бы не делать,
             оставив вызов методов Setting_са внутри класса TokenStream, но для исключения возможности
             неправильного включения заголовков и "забытого" файла настроек я принял решение сделать это явно.
             К тому же, теперь Token_ы получаются не только из консоли, но и из файлов
             (теоретически, при данной модели возможно получать их "откуда угодно"), а не хотелось очень
             "загромождать" алгоритмы вычисления дополнительными ссылками, да ещё и пришлось бы
             переделывать каждый "геттер" в них. Это и безопаснее:мы получаем только Stream::get() (Token),
             и совершенно не касаемся реализации ввода

        - 3) Файл считывается в режиме "защёлки" - после установки потока на считывания файла он автоматически
             считывает данные из файла до конца файла или другой фатальной ошибки, причём, дойдя до конца файла
             (или в случае ошибкм), поток сам устанавливает в настройках консоль как источник токенов

        - 4) Режим ввода (из файла или нет) выбирается в главном меню в отдельной функции, прредназначенной
             для забора данных из файла Причем вывод при вводе из файла настраивается отдельно
             от ввода из консоли (возможна ситуация, когда при вводе из консоли вывод будет
             производиться только в файл, а при вводе из файла - в консоль и наоборот - при вводе из консоли
             вывод будет только в консоль, а при вводе из файла - только в файл)
             При вводе из файла вывод в файл будет производиться в любом случае,

        - 5) вывод лога ошибок отделён от обработки и вывода исключений. В mamin_menu.cpp есть функция
             errors_handler для обработки ошибок. Она в настоящем положении создает и вызывает файл,
             свойства которого определены в Settings, а в Main_exception есть метод put_to_file,
             выводящий лог в настроенный файл. Данное решение более логично, чем реализовывать вывод файла в
             Main_exception, потому что вывод файла можно вывести по-разному.
             И в данном случае имя файла объявлено в настройках, и обработка файла произведена в mamin_menu.cpp.
             Это решение более гибкое. Хотя вывод производится априори в файл, его имя и контроль вывода
             находятся на более высоком уровне. Main_exception контролирует только необходимость вывода
             (указывается при создании исключения). Если не указано иначе, исключение будет записываться
             (архивироваться). Как правило, из-за особенностей вызова исключений, не нужно записывать конец
             считывания файла. Окончание считывания файла обрабатываетия как исключение, но записывать его
             нет необходимости. Впрочем, остается возможность это сделать или по-особому обработать конец файла.

        - 6) Для определения, нужно ли записывать в лог ошибок какое-то сообщение, есть перегруженнные
             конструкторы класса MainException. В него перелааются дефайны NOT_ARCHIVED_THIS_EXCEPTION,
             и другие "NOT_ARCHIVED -//-", объявленные в constantes.h. Смотри причины выше.

        - 7) Принято решение о создании справки как отдельного файла для
             более удобного её редактирования, причём вкупе с тем, что в классе Settings появилось поле
             с именем файла настроек есть возможность сделать вывод справки мультиязычным

        - 8) На случай необходимости доступа (или изменения) адресов лога и справки в Settings
             созданы поля их имён. Они в непосредственно в объекте, чтобы быть максимально на виду, но при этом
             не перегружать реализацию исключений и вывода справки

    _______________________________________________
    
        Программа "Small_calculator" представляет собой простой консольный калькулятор.
    Стандартными средствами консоли производятся вычисления - простые арифметические действия.
    Идея программы взята из учебников Строуструпа по языку прогаммирования C++, и переработана
    (Бьярне Строуструп, "Программирование: принципы и практика использования C++", 2009 год).
    Основным посылом программы является разделение постоянного потока входных данных на лексемы
    и непрерывная их обработка.

        Выкладываю толькот код программы, потому что планируется использование программы как
    кросс-платформенного решения.

        Для использования программы добавьте директорию Manuals в одну директорию с программой
    _______________________________________________
    Логика программы следующая:

        Третий уровень:
            Второй уровень + Второй уровень
            Второй уровень - Второй уровень
            Второй уровень
        Второй уровень:
            Первый уровень * Первый уровень
            Первый уровень / Первый уровень
            Первый уровень
        Первый уровень:
            Первичное выражение ^ Первичное выражение (возведение в степень)
        Первичное Выражение:
            + Первичное Выражение
            - Первичное Выражение
            ( Первичное Выражение )
            Число
            Переменная
            Константа
            Функция
        Функция:
            [Имя функции] Первичное Выражение
            [Имя функции] ( Первичное Выражение, Первичное выражение )
        Переменная:
            [Имя, Число]
        Константа:
            [Имя, Число]

        Объявление переменной:
            Ключевое слово [ var ],  Новое имя, '=', Первичное Выражение

        Изменение переменной:
            'Имя Переменной', '=', Первичное Выражение

        Ключевые слова:
            [ Имя ]
        Новое имя: Любое Слово, не использовавшееся ранее

    _______________________________________________
