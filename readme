
    Small_calculator - версия 3.0.0
    Работа начата 24.04.2023, закончена - 6.12.2023.

    Автор: Калинушкин Владимир, ya-vladimir-93@yandex.ru
    _______________________________________________
        Программа "Small_calculator" представляет собой простой консольный калькулятор.
    Стандартными средствами консоли производятся вычисления - простые арифметические действия.
    Идея программы взята из учебников Строуструпа по языку прогаммирования C++, и переработана
    (Бьярне Строуструп, "Программирование: принципы и практика использования C++", 2009 год).
    Основным посылом программы является разделение постоянного потока входных данных на лексемы
    и непрерывная их обработка.

        Выкладываю толькот код программы, потому что планируется использование программы как
    кросс-платформенного решения.

        Для использования программы добавьте директорию Manuals в одну директорию с программой
    _______________________________________________
    Логика программы следующая:

        Третий уровень:
            Второй уровень + Второй уровень
            Второй уровень - Второй уровень
            Второй уровень
        Второй уровень:
            Первый уровень * Первый уровень
            Первый уровень / Первый уровень
            Первый уровень
        Первый уровень:
            Первичное выражение ^ Первичное выражение (возведение в степень)
        Первичное Выражение:
            + Первичное Выражение
            - Первичное Выражение
            ( Первичное Выражение )
            Число
            Переменная
            Константа
            Функция
        Функция:
            [Имя функции] Первичное Выражение
            [Имя функции] ( Первичное Выражение, Первичное выражение )
        Переменная:
            [Имя, Число]
        Константа:
            [Имя, Число]

        Объявление переменной:
            Ключевое слово [ var ],  Новое имя, '=', Первичное Выражение

        Изменение переменной:
            'Имя Переменной', '=', Первичное Выражение

        Ключевые слова:
            [ Имя ]
        Новое имя: Любое Слово, не использовавшееся ранее

    _______________________________________________

    Новое:

        1) Из функционала:
            - a) создан ввод-вывод из файла
            - b) реализована тонкая настройка программы
            - c) теперь ведется лог ошибок
            - d) добавлена функция clear для очистки экрана

        2) Из технического:

            - a) типы лексем выведены в одно "псевдо-перечисление" (макроc BETTER_ENUM,
                 Libraries/better-enums, смотри https://github.com/aantron/better-enums/tree/master)

            - b) создан отдельный класс Main_exception для обработки исключений
            - c) он же выводит данные об ошибке в лог-файл
            - d) создан класс Mathematic_result для вывода результата
            - e) все "стандартные" заголовки убраны - оставлены только необходимые
                 (несколько "общих функций", взятых из личных библиотек помещены в
                 Libraries/other_functions.hpp)

            - f) следующая иерархия файлов:

                - а) Small_calculator.cpp, Small_calculator.h, constantes.h, global_static_objects.h -
                     - для "ядра" порядок включения заголовков, констант и глобальных объектов важен -
                     - многие классы и логика программы зависят один от другого (об этом ниже)
                - б) Main_menu
                - в) далее папки All_calculation_modes, Libraries, Custom_classes
                - г) в заключение - директория Manuals (см. примечание 7)

            - g) для потенциально долгой обработки вводимого файла создан индикатор задержки
                    (находится в All_calculation_modes/enable_mathematic_mode.cpp (и ...h))

            - h) переделан класс Settings - теперь сама настройка производится в подменю главного меню
                 (масло маслянное =))) ), а Settings хранит и возвращает параметры,
                 с возможностью, конечно, их изменить

            - h) для корректной работы исключений (правильной инициализации объекта исключения)
                 при инициализации токена поле type устанавливается налом (Смотри примечание 1)

            - i) Немного модифицирована функция очистки потока Stream::clear (void).
                 Теперь она очищает консоль или буфер файла в зависимости от настроенного инструмента ввода

            - j) Метод Token::get() (Token) перенесён в TokenStream,
                 метод TokenStream::read_token(istream &is) (Token).
                 Стоит учесть, что перегруженный оператор << вывода в ostreamn помещён в class_MainException.cpp

            - k) Теперь метод TokenStream::get(), получая токены проверяет, есть ли символ в Type_lexeme
                 (для этого введен BETTER_ENUM). Чтобы исключить обработку символа выхода и символа вызова
                 справки (это - строковые символы) метод TokenStream::read_token() после проверки на то,
                 что токен - число проверяет условие: если символ - буква, то или за ним должна идти буква
                 (это в любом случае слово), или этот символ не должен быть символом выхода или вызова справки

            - l) В главном меню наведён порядок. Идет проверка на символ выхода, затем проверка на вызов
                 "главных режимов" (main_modes). Причём и то, и то производится при условии ввода из консоли.
                 Из файла нельзя ни вызвать выход из программы, ни вызвать подменю

    _______________________________________________

    Пояснения:

        - 1) Для чего поле токена устанавливается налом (2.h). На логику работы это никак не влияет:
             токен после создания почти сразу получает реальные значения, а в классе Main_exception токен -
             - часть объекта (для того, чтобы по возможности получить и передать пользователю информацию
             о проблемном месте в выражении (конечно, чтобы найти ошибку в введённом выражении =)) )),
             но, если при инициализации объекта исключения не был передан токен (это не всегда нужно),
             в выводе сообщения не нужно выводить "случайные" значения "встроенного" токена,
             достаточно ограничиться строкой "no_token" в логе, а в консоли вообще ничего не выводить

        - 2) Объект класса TokenStream должен инициализироваться с адресом Settings. Для этого в объекте
             класса Stream есть поле указателем на кобъект Settings. Этого можно было бы не делать,
             оставив вызов методов Setting_са внутри класса TokenStream, но для исключения возможности
             неправильного включения заголовков и "забытого" файла настроек я принял решение сделать это явно.
             К тому же, теперь Token_ы получаются не только из консоли, но и из файлов
             (теоретически, при данной модели возможно получать их "откуда угодно"), а не хотелось очень
             "загромождать" алгоритмы вычисления дополнительными ссылками, да ещё и пришлось бы
             переделывать каждый "геттер" в них. Это и безопаснее:мы получаем только Stream::get() (Token),
             и совершенно не касаемся реализации ввода

        - 3) Файл считывается в режиме "защёлки" - после установки потока на считывания файла он автоматически
             считывает данные из файла до конца файла или другой фатальной ошибки, причём, дойдя до конца файла
             (или в случае ошибкм), поток сам устанавливает в настройках консоль как источник токенов

        - 4) Режим ввода (из файла или нет) выбирается в главном меню в отдельной функции, прредназначенной
             для забора данных из файла Причем вывод при вводе из файла настраивается отдельно
             от ввода из консоли (возможна ситуация, когда при вводе из консоли вывод будет
             производиться только в файл, а при вводе из файла - в консоль и наоборот - при вводе из консоли
             вывод будет только в консоль, а при вводе из файла - только в файл)
             При вводе из файла вывод в файл будет производиться в любом случае,

        - 5) вывод лога ошибок отделён от обработки и вывода исключений. В mamin_menu.cpp есть функция
             errors_handler для обработки ошибок. Она в настоящем положении создает и вызывает файл,
             свойства которого определены в Settings, а в Main_exception есть метод put_to_file,
             выводящий лог в настроенный файл. Данное решение более логично, чем реализовывать вывод файла в
             Main_exception, потому что вывод файла можно вывести по-разному.
             И в данном случае имя файла объявлено в настройках, и обработка файла произведена в mamin_menu.cpp.
             Это решение более гибкое. Хотя вывод производится априори в файл, его имя и контроль вывода
             находятся на более высоком уровне. Main_exception контролирует только необходимость вывода
             (указывается при создании исключения). Если не указано иначе, исключение будет записываться
             (архивироваться). Как правило, из-за особенностей вызова исключений, не нужно записывать конец
             считывания файла. Окончание считывания файла обрабатываетия как исключение, но записывать его
             нет необходимости. Впрочем, остается возможность это сделать или по-особому обработать конец файла.

        - 6) Для определения, нужно ли записывать в лог ошибок какое-то сообщение, есть перегруженнные
             конструкторы класса MainException. В него перелааются дефайны NOT_ARCHIVED_THIS_EXCEPTION,
             и другие "NOT_ARCHIVED -//-", объявленные в constantes.h. Смотри причины выше.

        - 7) Принято решение о создании справки как отдельного файла для
             более удобного её редактирования, причём вкупе с тем, что в классе Settings появилось поле
             с именем файла настроек есть возможность сделать вывод справки мультиязычным

        - 8) На случай необходимости доступа (или изменения) адресов лога и справки в Settings
             созданы поля их имён. Они в непосредственно в объекте, чтобы быть максимально на виду, но при этом
             не перегружать реализацию исключений и вывода справки

    _______________________________________________
